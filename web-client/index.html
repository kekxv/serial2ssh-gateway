<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Serial & BLE Terminal</title>
    <!-- xterm.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1e1e1e;
            color: #c9d1d9;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        header {
            padding: 10px 20px;
            background-color: #2d2d2d;
            border-bottom: 1px solid #3e3e3e;
            display: flex;
            align-items: center;
            gap: 5px; /* Reduced gap */
            flex-wrap: wrap;
        }
        h1 {
            margin: 0;
            font-size: 1.2rem;
            margin-right: auto;
        }
        #terminal-container {
            flex: 1;
            /* Remove padding from container, let xterm fill it and use its internal padding/margin if needed */
            overflow: hidden;
        }
        button {
            background-color: #238636;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap;
        }
        button:hover {
            background-color: #2ea043;
        }
        button:disabled {
            background-color: #444;
            cursor: not-allowed;
        }
        button.ble {
            background-color: #0078d7;
        }
        button.ble:hover {
            background-color: #1084e3;
        }
        button.disconnect {
            background-color: #da3633;
        }
        button.disconnect:hover {
            background-color: #f85149;
        }
        select, input {
            padding: 5px;
            border-radius: 4px;
            background: #0d1117;
            color: #c9d1d9;
            border: 1px solid #30363d;
        }
        .status {
            font-size: 0.85rem;
            color: #8b949e;
            white-space: nowrap;
        }
        .separator {
            width: 1px;
            height: 24px;
            background-color: #3e3e3e;
            margin: 0 5px;
        }
        /* Hidden class for toggling visibility */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

<header>
    <h1>Web Console</h1>
    <span id="statusMsg" class="status">Disconnected</span>
    
    <div class="separator"></div>

    <!-- Serial Controls -->
    <div id="serialControls" style="display: flex; gap: 10px; align-items: center;">
        <select id="baudRate">
            <option value="9600">9600</option>
            <option value="19200">19200</option>
            <option value="38400">38400</option>
            <option value="57600">57600</option>
            <option value="115200" selected>115200</option>
        </select>
        <button id="connectSerialBtn">Serial Connect</button>
    </div>

    <div class="separator"></div>

    <!-- BLE Controls -->
    <div id="bleControls" style="display: flex; gap: 10px; align-items: center;">
        <button id="connectBleBtn" class="ble">BLE Connect</button>
    </div>

    <!-- Active Session Controls (Hidden until connected) -->
    <div id="activeSessionControls" class="hidden" style="display: flex; gap: 10px; align-items: center;">
        <div class="separator"></div>
        <button id="sendKeyBtn" title="Upload Private Key File" style="background-color: #238636;">Key ðŸ”‘</button>
        <input type="file" id="keyFileUpload" style="display: none;" />
    </div>

    <div class="separator"></div>

    <!-- Collab Controls -->
    <div id="collabControls" style="display: flex; gap: 10px; align-items: center;">
        <input type="text" id="wsUrlInput" value="ws://localhost:8080" placeholder="ws://host:port" style="width: 150px; font-family: monospace; font-size: 0.8rem;">
        <div class="separator"></div>
        <input type="text" id="shareCodeInput" placeholder="Code" style="width: 120px; font-family: monospace;">
        <button id="joinBtn" style="background-color: #8957e5;">Join</button>
        <button id="shareBtn" style="background-color: #d29922;">Share</button>
    </div>
    <span id="collabStatus" class="status hidden" style="color: #d29922; font-weight: bold;"></span>

    <button id="disconnectBtn" class="disconnect hidden">Disconnect</button>

</header>

<div id="terminal-container"></div>

<!-- xterm.js Library -->
<script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.js"></script>

<script>
    // --- Constants ---
    // Nordic UART Service (NUS)
    const NUS_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    const NUS_RX_CHAR = '6e400002-b5a3-f393-e0a9-e50e24dcca9e'; // Write
    const NUS_TX_CHAR = '6e400003-b5a3-f393-e0a9-e50e24dcca9e'; // Notify

    // HM-10 / JDY-08 / CC2541 (Standard 16-bit UUIDs often expanded)
    const HM10_SERVICE_UUID = '0000ffe0-0000-1000-8000-00805f9b34fb';
    const HM10_CHAR_UUID    = '0000ffe1-0000-1000-8000-00805f9b34fb'; // Read/Write/Notify

    // "KT" Style Service (from bluetooth.ts)
    const KT_SERVICE_UUID = '0000fff0-0000-1000-8000-00805f9b34fb'; // 0xfff0
    const KT_CHAR_UUID    = '0000fff1-0000-1000-8000-00805f9b34fb'; // 0xfff1

    const OPTIONAL_SERVICES = [NUS_SERVICE_UUID, HM10_SERVICE_UUID, KT_SERVICE_UUID];

    // --- UI Elements ---
    const connectSerialBtn = document.getElementById('connectSerialBtn');
    const connectBleBtn = document.getElementById('connectBleBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const baudRateSelect = document.getElementById('baudRate');
    const statusMsg = document.getElementById('statusMsg');
    const termContainer = document.getElementById('terminal-container');
    const serialControls = document.getElementById('serialControls');
    const bleControls = document.getElementById('bleControls');
    const activeSessionControls = document.getElementById('activeSessionControls');
    const collabControls = document.getElementById('collabControls');
    const shareBtn = document.getElementById('shareBtn');
    const joinBtn = document.getElementById('joinBtn');
    const shareCodeInput = document.getElementById('shareCodeInput');
    const wsUrlInput = document.getElementById('wsUrlInput');
    const collabStatus = document.getElementById('collabStatus');

    // --- State ---
    let transport = null; // Holds the active transport object (Serial or BLE)
    let collab = null;    // Holds the CollabManager
    
    // --- Initialize xterm.js ---
    const term = new Terminal({
        cursorBlink: true,
        theme: {
            background: '#1e1e1e',
            foreground: '#c9d1d9'
        },
        fontSize: 14,
        fontFamily: 'Menlo, Monaco, "Courier New", monospace'
    });
    
    const fitAddon = new FitAddon.FitAddon();
    term.loadAddon(fitAddon);
    term.loadAddon(new WebLinksAddon.WebLinksAddon());

    term.open(termContainer);
    fitAddon.fit();

    window.addEventListener('resize', () => fitAddon.fit());

    term.writeln('\x1b[1;32mWelcome to Web Serial & BLE Console!\x1b[0m');
    term.writeln('Choose a connection method above to start.');

    // --- Terminal Input Handling ---
    term.onData((data) => {
        // Case 1: We are a Guest -> Send to Host via Collab
        if (collab && collab.isGuest) {
            collab.sendInput(data);
            return;
        }

        // Case 2: We are the Host (or local user) -> Write to local transport
        if (transport && transport.write) {
            transport.write(data);
        }
    });

    // --- Collab Manager ---
    class CollabManager {
        constructor(url) {
            this.url = url;
            this.ws = null;
            this.isHost = false;
            this.isGuest = false;
        }

        connect() {
            return new Promise((resolve, reject) => {
                this.ws = new WebSocket(this.url);
                this.ws.onopen = () => resolve();
                this.ws.onerror = (err) => reject(err);
                this.ws.onmessage = this.handleMessage.bind(this);
                this.ws.onclose = () => {
                    this.handleDisconnect();
                };
            });
        }

        handleMessage(event) {
            const msg = JSON.parse(event.data);
            switch (msg.type) {
                case 'created':
                    this.isHost = true;
                    this.isGuest = false;
                    updateCollabUI(true, `Hosting: ${msg.code}`);
                    term.writeln(`\r\n\x1b[1;35mSession Created!\r\nShare Code: ${msg.code}\x1b[0m`);
                    // Auto-fill the code input so user can copy it
                    shareCodeInput.value = msg.code; 
                    break;
                case 'joined':
                    this.isHost = false;
                    this.isGuest = true;
                    updateCollabUI(true, `Joined: ${msg.code}`);
                    term.writeln(`\r\n\x1b[1;35mJoined Session: ${msg.code}\x1b[0m`);
                    // Disable local transport controls if we are guest
                    serialControls.classList.add('hidden');
                    bleControls.classList.add('hidden');
                    // Show activeSessionControls for Guest too
                    activeSessionControls.classList.remove('hidden');
                    activeSessionControls.style.display = 'flex';
                    break;
                case 'term_data':
                    if (this.isGuest) {
                        // Receive output from Host -> Write to Terminal
                        term.write(msg.data);
                    } else if (this.isHost) {
                        // Receive input from Guest -> Write to Local Transport
                        if (transport) transport.write(msg.data);
                    }
                    break;
                case 'error':
                    term.writeln(`\r\n\x1b[1;31mCollab Error: ${msg.message}\x1b[0m`);
                    break;
            }
        }

        handleDisconnect() {
            updateCollabUI(false);
            term.writeln(`\r\n\x1b[1;33mCollab Disconnected.\x1b[0m`);
            this.ws = null;
            this.isHost = false;
            this.isGuest = false;
            // Restore controls
            if (!transport) {
                serialControls.classList.remove('hidden');
                bleControls.classList.remove('hidden');
            }
            activeSessionControls.classList.add('hidden'); // Hide for all on disconnect
            activeSessionControls.style.display = 'none';
        }

        createSession() {
            if (!this.ws) return;
            this.ws.send(JSON.stringify({ type: 'create' }));
        }

        joinSession(code) {
            if (!this.ws) return;
            this.ws.send(JSON.stringify({ type: 'join', code: code }));
        }

        // Called by Host when local transport receives data
        broadcastOutput(data) {
            if (this.ws && this.isHost && this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({ type: 'term_data', data: data }));
            }
        }

        // Called by Guest when user types
        sendInput(data) {
            if (this.ws && this.isGuest && this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({ type: 'term_data', data: data }));
            }
        }
    }

    // --- Transport Classes ---

    class SerialTransport {
        constructor() {
            this.port = null;
            this.reader = null;
            this.inputDone = null;
            this.outputDone = null;
            this.outputStream = null;
            this.writer = null;
        }

        async connect() {
            if (!("serial" in navigator)) {
                throw new Error("Web Serial API not supported.");
            }
            
            this.port = await navigator.serial.requestPort();
            const baudRate = parseInt(baudRateSelect.value);
            await this.port.open({ baudRate: baudRate });

            // Setup Write Stream
            const encoder = new TextEncoderStream();
            this.outputDone = encoder.readable.pipeTo(this.port.writable);
            this.outputStream = encoder.writable;
            this.writer = this.outputStream.getWriter();

            // Setup Read Stream - Read raw bytes directly
            this.reader = this.port.readable.getReader();
            // No TextDecoderStream here to maintain binary transparency

            this.readLoop();
            return `Serial (${baudRate})`;
        }

        async readLoop() {
            while (true) {
                try {
                    const { value, done } = await this.reader.read(); // value is Uint8Array
                    if (done) break;
                    if (value) {
                        term.write(value); // xterm.js can handle Uint8Array
                        // If we are hosting, broadcast this data as a string
                        if (collab && collab.isHost) {
                            const decodedString = new TextDecoder('utf-8').decode(value);
                            collab.broadcastOutput(decodedString);
                        }
                    }
                } catch (error) {
                    console.error('Serial Read Error', error);
                    break;
                }
            }
        }

        async write(data) {
            if (!this.writer) return;
            
            // Chunking for Serial is also good practice to prevent buffer overflow on receiver
            const CHUNK_SIZE = 128; // Can be larger than BLE, but safe limit
            
            for (let i = 0; i < data.length; i += CHUNK_SIZE) {
                const chunk = data.slice(i, i + CHUNK_SIZE);
                await this.writer.write(chunk);
                // Tiny delay to let the event loop breathe and hardware catch up
                if (data.length > CHUNK_SIZE) {
                    await new Promise(r => setTimeout(r, 5));
                }
            }
        }

        async disconnect() {
            if (this.reader) {
                await this.reader.cancel();
                await this.inputDone.catch(() => {});
                this.reader = null;
                this.inputDone = null;
            }
            if (this.outputStream) {
                await this.outputStream.close();
                await this.outputDone;
                this.outputStream = null;
                this.outputDone = null;
            }
            if (this.port) {
                await this.port.close();
                this.port = null;
            }
        }
    }

    class BLETransport {
        constructor() {
            this.device = null;
            this.rxChar = null; // We write to this
            this.txChar = null; // We receive notifications from this
        }

        async connect() {
            if (!("bluetooth" in navigator)) {
                throw new Error("Web Bluetooth API not supported.");
            }

            // Request ANY device, but we must declare which services we might want to access
            this.device = await navigator.bluetooth.requestDevice({
                acceptAllDevices: true,
                optionalServices: OPTIONAL_SERVICES
            });

            if (!this.device.gatt) {
                throw new Error("Device does not support GATT.");
            }

            const server = await this.device.gatt.connect();
            
            // Service Discovery Logic
            // Try Nordic NUS first, then HM-10, then KT
            let service = null;
            let type = '';

            // 1. Nordic NUS
            try {
                service = await server.getPrimaryService(NUS_SERVICE_UUID);
                this.rxChar = await service.getCharacteristic(NUS_RX_CHAR);
                this.txChar = await service.getCharacteristic(NUS_TX_CHAR);
                type = 'Nordic NUS';
            } catch (e) {
                console.log("NUS service not found.");
            }

            // 2. HM-10
            if (!service) {
                try {
                    service = await server.getPrimaryService(HM10_SERVICE_UUID);
                    const characteristic = await service.getCharacteristic(HM10_CHAR_UUID);
                    this.rxChar = characteristic;
                    this.txChar = characteristic;
                    type = 'HM-10/JDY';
                } catch (e) {
                    console.log("HM-10 service not found.");
                }
            }

            // 3. KT (from bluetooth.ts)
            if (!service) {
                try {
                    service = await server.getPrimaryService(KT_SERVICE_UUID);
                    const characteristic = await service.getCharacteristic(KT_CHAR_UUID);
                    this.rxChar = characteristic;
                    this.txChar = characteristic;
                    type = 'KT/FFF0';
                } catch (e) {
                    console.log("KT service not found.");
                }
            }

            if (!service || !this.rxChar || !this.txChar) {
                throw new Error("No supported UART service found (checked Nordic NUS, HM-10 & KT).");
            }

            // Listen for updates
            await this.txChar.startNotifications();
            this.txChar.addEventListener('characteristicvaluechanged', this.handleNotifications.bind(this));
            
            this.device.addEventListener('gattserverdisconnected', () => {
               term.writeln('\r\n\x1b[1;31mBLE Device Disconnected unexpectedly.\x1b[0m');
               disconnect(); 
            });

            return `BLE (${this.device.name || 'Unknown'} - ${type})`;
        }

        handleNotifications(event) {
            const value = event.target.value; // This is a DataView
            const uint8Array = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
            term.write(uint8Array); // xterm.js can handle Uint8Array
            
            // If we are hosting, broadcast this data as a string
            if (collab && collab.isHost) {
                const decodedString = new TextDecoder('utf-8').decode(uint8Array);
                collab.broadcastOutput(decodedString);
            }
        }

        async write(data) {
            if (!this.rxChar) return;
            
            const encoder = new TextEncoder('utf-8');
            const array = encoder.encode(data);
            const CHUNK_SIZE = 20; // Safe default MTU payload for BLE 4.0+

            for (let i = 0; i < array.length; i += CHUNK_SIZE) {
                const chunk = array.slice(i, i + CHUNK_SIZE);
                try {
                    // Try WriteWithoutResponse first (faster)
                    await this.rxChar.writeValueWithoutResponse(chunk);
                } catch (err) {
                    console.error("BLE WriteWithoutResponse Error:", err);
                    // Fallback to regular Write
                     try {
                         await this.rxChar.writeValue(chunk);
                     } catch (retryErr) {
                         term.writeln(`\r\n\x1b[1;31mBLE Write Error: ${retryErr.message}\x1b[0m`);
                         break; // Stop sending rest of message
                     }
                }
                // Minimal delay to prevent flooding the stack if promises resolve too fast
                // (though await writeValue is usually sufficient flow control)
                // await new Promise(r => setTimeout(r, 5)); 
            }
        }

        async disconnect() {
            if (this.device && this.device.gatt.connected) {
                this.device.gatt.disconnect();
            }
            this.device = null;
            this.rxChar = null;
            this.txChar = null;
        }
    }

    // --- Main Logic ---

    connectSerialBtn.addEventListener('click', () => startConnection(new SerialTransport()));
    connectBleBtn.addEventListener('click', () => startConnection(new BLETransport()));
    disconnectBtn.addEventListener('click', disconnect);

    // Key Upload Logic
    const sendKeyBtn = document.getElementById('sendKeyBtn');
    const keyFileUpload = document.getElementById('keyFileUpload');

    sendKeyBtn.addEventListener('click', () => {
        // If collaborating as a Guest, allow sending key via collab
        if (collab && collab.isGuest) {
            keyFileUpload.click();
            return;
        }

        if (!transport) {
            alert("Please connect to Serial or BLE first.");
            return;
        }
        keyFileUpload.click();
    });

    keyFileUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async (ev) => {
            const content = ev.target.result;
            const CHUNK_SIZE = 64; 
            
            term.writeln(`\r\n\x1b[1;34mSending Key (${content.length} bytes)...\x1b[0m`);
            
            for (let i = 0; i < content.length; i += CHUNK_SIZE) {
                const chunk = content.slice(i, i + CHUNK_SIZE);
                if (collab && collab.isGuest) {
                    // If guest, send via collab manager
                    collab.sendInput(chunk);
                } else if (transport && transport.write) {
                    // Else (host or local only), send via local transport
                    await transport.write(chunk);
                }
                // Small delay is crucial for flow control
                await new Promise(r => setTimeout(r, 20)); 
            }

            // Ensure a final newline is sent if missing, to trigger backend line processing
            if (!content.endsWith('\n') && !content.endsWith('\r')) {
                 if (collab && collab.isGuest) {
                    collab.sendInput("\n");
                 } else if (transport && transport.write) {
                    await transport.write("\n");
                 }
            }
            
            term.writeln(`\r\n\x1b[1;32mKey Sent!\x1b[0m`);
            // Reset input so we can upload same file again if needed
            keyFileUpload.value = '';
        };
        reader.readAsText(file);
    });

    // Collab Listeners
    shareBtn.addEventListener('click', async () => {
        await initCollab();
        collab.createSession();
    });

    joinBtn.addEventListener('click', async () => {
        const code = shareCodeInput.value.trim();
        if (!code) {
            alert("Please enter a code to join.");
            return;
        }
        await initCollab();
        collab.joinSession(code);
    });

    async function initCollab() {
        if (collab) return; // Already initialized
        
        // Use the user-provided URL
        let url = wsUrlInput.value.trim();
        if (!url) {
             // Fallback/Default
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname || 'localhost';
            url = `${protocol}//${host}:8080`;
            wsUrlInput.value = url; // Show default back to user
        }
        
        collab = new CollabManager(url);
        try {
            await collab.connect();
            term.writeln(`\r\n\x1b[1;34mConnected to Collaboration Server (${url}).\x1b[0m`);
        } catch (e) {
            term.writeln(`\r\n\x1b[1;31mFailed to connect to Collaboration Server at ${url}.\x1b[0m`);
            collab = null;
            throw e;
        }
    }

    function updateCollabUI(active, text) {
        if (active) {
            collabControls.classList.add('hidden'); // Hide buttons
            collabStatus.textContent = text;
            collabStatus.classList.remove('hidden');
        } else {
            collabControls.classList.remove('hidden');
            collabStatus.classList.add('hidden');
        }
    }

    async function startConnection(newTransport) {
        try {
            transport = newTransport;
            const statusText = await transport.connect();
            
            // Update UI
            statusMsg.textContent = `Connected: ${statusText}`;
            statusMsg.style.color = '#2ea043';
            
            serialControls.classList.add('hidden');
            bleControls.classList.add('hidden');
            
            activeSessionControls.classList.remove('hidden');
            activeSessionControls.style.display = 'flex'; // Force flex layout
            
            disconnectBtn.classList.remove('hidden');
            
            term.writeln(`\r\n\x1b[1;32mConnected via ${statusText}!\x1b[0m`);
            term.focus();

        } catch (err) {
            console.error(err);
            term.writeln(`\r\n\x1b[1;31mConnection Failed: ${err.message}\x1b[0m`);
            transport = null;
        }
    }

    async function disconnect() {
        if (transport) {
            await transport.disconnect();
            transport = null;
        }
        
        statusMsg.textContent = 'Disconnected';
        statusMsg.style.color = '#8b949e';
        
        serialControls.classList.remove('hidden');
        bleControls.classList.remove('hidden');
        
        activeSessionControls.classList.add('hidden');
        activeSessionControls.style.display = 'none'; // Ensure hidden
        
        disconnectBtn.classList.add('hidden');
        
        term.writeln('\r\n\x1b[1;33mDisconnected.\x1b[0m');
    }
</script>

</body>
</html>